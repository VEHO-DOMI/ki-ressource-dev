<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stadtmodelle - Urbane Strukturmodelle im Vergleich</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #0a0a1a 0%, #1a0030 50%, #2d0050 100%);
            color: #f0f0f0;
            min-height: 100vh;
            overflow: hidden;
        }

        .container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            padding: 20px;
            height: 100vh;
        }

        @media (max-width: 900px) {
            .container {
                grid-template-columns: 1fr;
                gap: 15px;
                padding: 15px;
                height: auto;
                overflow-y: auto;
            }
        }

        .canvas-container {
            position: relative;
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        canvas {
            display: block;
            cursor: crosshair;
        }

        .controls-panel {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 25px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .header {
            text-align: center;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            padding-bottom: 15px;
        }

        .header h1 {
            font-size: 24px;
            font-weight: 700;
            margin-bottom: 5px;
            background: linear-gradient(135deg, #00d4ff, #0099ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .header p {
            font-size: 12px;
            color: #a0a0b0;
            font-weight: 300;
        }

        .model-buttons {
            display: grid;
            grid-template-columns: 1fr;
            gap: 10px;
        }

        .btn {
            padding: 12px 16px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background: rgba(255, 255, 255, 0.05);
            color: #f0f0f0;
            border-radius: 8px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 600;
            transition: all 0.3s ease;
            font-family: 'Inter', sans-serif;
        }

        .btn:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
        }

        .btn.active {
            background: linear-gradient(135deg, #00d4ff, #0099ff);
            border-color: #00d4ff;
            color: #000;
            box-shadow: 0 0 20px rgba(0, 212, 255, 0.3);
        }

        .section {
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            padding-top: 15px;
        }

        .section-title {
            font-size: 12px;
            font-weight: 700;
            color: #00d4ff;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 12px;
        }

        .timeline-container {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .timeline-label {
            display: flex;
            justify-content: space-between;
            font-size: 11px;
            color: #a0a0b0;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: rgba(255, 255, 255, 0.1);
            outline: none;
            -webkit-appearance: none;
            appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: linear-gradient(135deg, #00d4ff, #0099ff);
            cursor: pointer;
            box-shadow: 0 0 10px rgba(0, 212, 255, 0.3);
            border: 2px solid rgba(255, 255, 255, 0.2);
        }

        input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: linear-gradient(135deg, #00d4ff, #0099ff);
            cursor: pointer;
            box-shadow: 0 0 10px rgba(0, 212, 255, 0.3);
            border: 2px solid rgba(255, 255, 255, 0.2);
        }

        .toggle-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .toggle {
            display: flex;
            align-items: center;
            gap: 10px;
            cursor: pointer;
            padding: 8px 0;
        }

        .toggle-switch {
            position: relative;
            width: 40px;
            height: 24px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            transition: all 0.3s ease;
        }

        .toggle-switch::after {
            content: '';
            position: absolute;
            width: 20px;
            height: 20px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            top: 2px;
            left: 2px;
            transition: all 0.3s ease;
        }

        .toggle input {
            display: none;
        }

        .toggle input:checked + .toggle-switch {
            background: rgba(0, 212, 255, 0.2);
            border-color: #00d4ff;
        }

        .toggle input:checked + .toggle-switch::after {
            left: 18px;
            background: #00d4ff;
        }

        .toggle-label {
            font-size: 13px;
            font-weight: 500;
            flex: 1;
        }

        .info-panel {
            background: rgba(0, 212, 255, 0.05);
            border: 1px solid rgba(0, 212, 255, 0.2);
            border-radius: 8px;
            padding: 12px;
            font-size: 12px;
            line-height: 1.6;
            color: #d0d0e0;
        }

        .legend {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 11px;
        }

        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 2px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            flex-shrink: 0;
        }

        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid rgba(0, 212, 255, 0.5);
            border-radius: 6px;
            padding: 8px 12px;
            font-size: 11px;
            color: #f0f0f0;
            pointer-events: none;
            z-index: 100;
            max-width: 150px;
            white-space: normal;
            display: none;
            backdrop-filter: blur(5px);
        }

        .tooltip-title {
            font-weight: 600;
            color: #00d4ff;
            margin-bottom: 4px;
        }

        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: transparent;
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.2);
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="canvas-container">
            <canvas id="canvas"></canvas>
            <div id="tooltip" class="tooltip"></div>
        </div>

        <div class="controls-panel">
            <div class="header">
                <h1>Stadtmodelle</h1>
                <p>Urbane Strukturmodelle im Vergleich</p>
            </div>

            <div class="model-buttons">
                <button class="btn active" data-model="burgess">Burgess-Modell (Zonen)</button>
                <button class="btn" data-model="hoyt">Hoyt-Modell (Sektoren)</button>
                <button class="btn" data-model="harris">Harris-Ullman-Modell (Mehrkerne)</button>
            </div>

            <div class="section">
                <div class="section-title">Zeitliche Entwicklung</div>
                <div class="timeline-container">
                    <div class="timeline-label">
                        <span>1900</span>
                        <span id="yearDisplay">1960</span>
                        <span>2020</span>
                    </div>
                    <input type="range" id="timeline" min="1900" max="2020" value="1960" step="10">
                </div>
            </div>

            <div class="section">
                <div class="section-title">Optionen</div>
                <div class="toggle-group">
                    <label class="toggle">
                        <input type="checkbox" id="showLabels" checked>
                        <div class="toggle-switch"></div>
                        <span class="toggle-label">Zonenbeschriftungen</span>
                    </label>
                    <label class="toggle">
                        <input type="checkbox" id="showVienna">
                        <div class="toggle-switch"></div>
                        <span class="toggle-label">Wien-Vergleich</span>
                    </label>
                    <label class="toggle">
                        <input type="checkbox" id="showCommuters">
                        <div class="toggle-switch"></div>
                        <span class="toggle-label">Pendlerbewegung</span>
                    </label>
                </div>
            </div>

            <div class="section">
                <div class="section-title">Modellbeschreibung</div>
                <div class="info-panel" id="infoPanel">
                    Das Burgess-Modell beschreibt die urbane Struktur als konzentrische Zonen rund um ein zentrales Geschäftsviertel. Die Zonen erweitern sich nach außen mit zunehmend besserer Wohnqualität.
                </div>
            </div>

            <div class="section">
                <div class="section-title">Legende</div>
                <div class="legend" id="legend"></div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const tooltip = document.getElementById('tooltip');

        // Set canvas size
        function resizeCanvas() {
            const container = canvas.parentElement;
            canvas.width = container.offsetWidth;
            canvas.height = container.offsetHeight;
            draw();
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // State
        const state = {
            model: 'burgess',
            year: 1960,
            showLabels: true,
            showVienna: false,
            showCommuters: false,
            hoveredZone: null
        };

        // Zone definitions
        const zones = {
            burgess: [
                { name: 'CBD / Geschäftsviertel', radius: 0.15, color: '#ff4444', description: 'Zentrum mit Geschäften, Banken und Verwaltung' },
                { name: 'Übergangszone', radius: 0.35, color: '#cc8844', description: 'Industrie, Gewerbe und kleine Fabriken' },
                { name: 'Arbeiter-Wohnviertel', radius: 0.55, color: '#4488ff', description: 'Wohngebiete für Arbeiterfamilien mit einfachen Häusern' },
                { name: 'Mittelschicht-Wohnviertel', radius: 0.75, color: '#44cc44', description: 'Bessere Wohnviertel für die Mittelschicht' },
                { name: 'Pendlergürtel / Vororte', radius: 0.95, color: '#99ff99', description: 'Vorstädte mit Einfamilienhäusern und guter Verkehrsanbindung' }
            ],
            hoyt: [
                { name: 'CBD / Geschäftsviertel', sector: true, size: 0.1, color: '#ff4444', description: 'Zentrum mit Geschäften, Banken und Verwaltung' },
                { name: 'Übergangszone', sector: true, size: 0.25, color: '#cc8844', description: 'Industrie entlang von Verkehrsachsen (Bahn, Straße)' },
                { name: 'Arbeiter-Wohnviertel', sector: true, size: 0.4, color: '#4488ff', description: 'Nähe zu Industrie und Gewerbe' },
                { name: 'Mittelschicht-Wohnviertel', sector: true, size: 0.65, color: '#44cc44', description: 'Bessere Lagen in bevorzugten Sektoren' },
                { name: 'Pendlergürtel / Vororte', sector: true, size: 0.95, color: '#99ff99', description: 'Expansive Entwicklung in besseren Sektoren' }
            ],
            harris: [
                { name: 'Haupt-CBD', x: 0.5, y: 0.5, size: 0.12, color: '#ff4444', description: 'Hauptzentrum mit Geschäften und Verwaltung' },
                { name: 'Neben-CBD', x: 0.75, y: 0.3, size: 0.08, color: '#ff6666', description: 'Sekundäres Geschäftszentrum' },
                { name: 'Industriezone', x: 0.25, y: 0.2, size: 0.1, color: '#cc8844', description: 'Industrielle Konzentration mit Arbeitskräften' },
                { name: 'Arbeiter-Wohnviertel', x: 0.3, y: 0.65, size: 0.15, color: '#4488ff', description: 'Nähe zu Industrie' },
                { name: 'Mittelschicht-Wohnviertel', x: 0.7, y: 0.7, size: 0.18, color: '#44cc44', description: 'Bessere Wohnlagen' },
                { name: 'Vororte', x: 0.15, y: 0.8, size: 0.12, color: '#99ff99', description: 'Suburbane Entwicklung' }
            ]
        };

        const modelDescriptions = {
            burgess: 'Das Burgess-Modell (1925) beschreibt die urbane Struktur als konzentrische Zonen rund um ein zentrales Geschäftsviertel. Jede Zone hat unterschiedliche Funktionen, von der wirtschaftlichen Nutzung bis zur Wohnnutzung. Die Zonen erweitern sich nach außen mit zunehmend besserer Wohnqualität und Platzverfügbarkeit.',
            hoyt: 'Das Hoyt-Modell (1939) erweitert das Burgess-Modell, indem es Sektoren statt Zonen berücksichtigt. Dabei spielen Verkehrsachsen (Eisenbahn, Straßen) eine wichtige Rolle für die räumliche Entwicklung. Industrie konzentriert sich entlang dieser Achsen, während bessere Wohnviertel sich in günstigen Sektoren ausbreiten.',
            harris: 'Das Harris-Ullman-Modell (1945) beschreibt Städte mit mehreren Kernen (Mehrkernmodell). Neben dem Haupt-CBD können sich weitere Zentren (Neben-CBD, Industriezonen) bilden. Jeder Kern zieht entsprechende Funktionen an und entwickelt sich zu eigenständigen Zentren mit umgebenden Wohngebieten.'
        };

        // Event listeners
        document.querySelectorAll('.btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                state.model = btn.dataset.model;
                document.getElementById('infoPanel').textContent = modelDescriptions[state.model];
                updateLegend();
                draw();
            });
        });

        document.getElementById('timeline').addEventListener('input', (e) => {
            state.year = parseInt(e.target.value);
            document.getElementById('yearDisplay').textContent = state.year;
            draw();
        });

        document.getElementById('showLabels').addEventListener('change', (e) => {
            state.showLabels = e.target.checked;
            draw();
        });

        document.getElementById('showVienna').addEventListener('change', (e) => {
            state.showVienna = e.target.checked;
            draw();
        });

        document.getElementById('showCommuters').addEventListener('change', (e) => {
            state.showCommuters = e.target.checked;
            draw();
        });

        canvas.addEventListener('mousemove', handleMouseMove);
        canvas.addEventListener('mouseleave', hideTooltip);

        // Update legend
        function updateLegend() {
            const legendEl = document.getElementById('legend');
            legendEl.innerHTML = '';
            zones[state.model].forEach(zone => {
                const item = document.createElement('div');
                item.className = 'legend-item';
                item.innerHTML = `
                    <div class="legend-color" style="background-color: ${zone.color}"></div>
                    <span>${zone.name}</span>
                `;
                legendEl.appendChild(item);
            });
        }
        updateLegend();

        // Utility functions
        function getGrowthFactor(year) {
            // Linear growth from 1900-2020
            return Math.max(0.2, (year - 1900) / (2020 - 1900));
        }

        function getAlpha(year) {
            // Opacity increases with time
            return 0.4 + (year - 1900) / (2020 - 1900) * 0.5;
        }

        // Drawing functions
        function drawBurgessModel() {
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const maxRadius = Math.min(canvas.width, canvas.height) / 2.5;
            const growthFactor = getGrowthFactor(state.year);
            const alpha = getAlpha(state.year);

            zones.burgess.forEach((zone, index) => {
                const radius = zone.radius * maxRadius * growthFactor;
                const nextRadius = index < zones.burgess.length - 1
                    ? zones.burgess[index + 1].radius * maxRadius * growthFactor
                    : radius + maxRadius * 0.1;

                // Draw zone ring
                ctx.beginPath();
                ctx.arc(centerX, centerY, nextRadius, 0, Math.PI * 2);
                ctx.arc(centerX, centerY, radius, 0, Math.PI * 2, true);
                ctx.fillStyle = zone.color + Math.floor(alpha * 255).toString(16).padStart(2, '0');
                ctx.fill();

                // Draw border
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Draw label
                if (state.showLabels && radius > 0) {
                    const labelRadius = (radius + nextRadius) / 2;
                    const labelX = centerX + Math.cos(0) * labelRadius;
                    const labelY = centerY + Math.sin(0) * labelRadius;
                    drawLabel(zone.name, labelX, labelY, zone.color);
                }
            });
        }

        function drawHoytModel() {
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const maxRadius = Math.min(canvas.width, canvas.height) / 2.5;
            const growthFactor = getGrowthFactor(state.year);
            const alpha = getAlpha(state.year);

            // Draw transport axis (railway)
            ctx.strokeStyle = 'rgba(100, 100, 100, 0.5)';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(centerX, centerY - maxRadius * 0.5);
            ctx.lineTo(centerX, centerY + maxRadius * 0.5);
            ctx.stroke();
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.strokeStyle = 'rgba(150, 150, 150, 0.3)';
            ctx.stroke();
            ctx.setLineDash([]);

            const sectorCount = 6;
            const sectorsPerZone = sectorCount / zones.hoyt.length;

            zones.hoyt.forEach((zone, zoneIndex) => {
                const maxSectorRadius = zone.size * maxRadius * growthFactor;
                const minSectorRadius = zoneIndex > 0 ? zones.hoyt[zoneIndex - 1].size * maxRadius * growthFactor : 0;

                for (let i = 0; i < sectorCount; i++) {
                    const startAngle = (i / sectorCount) * Math.PI * 2;
                    const endAngle = ((i + 1) / sectorCount) * Math.PI * 2;

                    ctx.beginPath();
                    ctx.moveTo(centerX, centerY);
                    ctx.arc(centerX, centerY, minSectorRadius, startAngle, endAngle);
                    ctx.lineTo(centerX, centerY);
                    ctx.fillStyle = zone.color + Math.floor(alpha * 255).toString(16).padStart(2, '0');
                    ctx.fill();

                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
                    ctx.lineWidth = 1;
                    ctx.stroke();

                    ctx.beginPath();
                    ctx.moveTo(centerX, centerY);
                    ctx.arc(centerX, centerY, maxSectorRadius, startAngle, endAngle);
                    ctx.lineTo(centerX, centerY);
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }

                if (state.showLabels && zoneIndex < 2) {
                    const angle = Math.PI / 3 * zoneIndex;
                    const labelRadius = (minSectorRadius + maxSectorRadius) / 2;
                    const labelX = centerX + Math.cos(angle) * labelRadius;
                    const labelY = centerY + Math.sin(angle) * labelRadius;
                    drawLabel(zone.name, labelX, labelY, zone.color);
                }
            });
        }

        function drawHarrisUllmanModel() {
            const growthFactor = getGrowthFactor(state.year);
            const alpha = getAlpha(state.year);

            zones.harris.forEach(zone => {
                const x = canvas.width * zone.x;
                const y = canvas.height * zone.y;
                const radius = zone.size * Math.min(canvas.width, canvas.height) * growthFactor;

                // Draw zone blob
                ctx.beginPath();
                for (let angle = 0; angle < Math.PI * 2; angle += 0.3) {
                    const variance = 1 + Math.sin(angle * 3) * 0.2;
                    const px = x + Math.cos(angle) * radius * variance;
                    const py = y + Math.sin(angle) * radius * variance;
                    if (angle === 0) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                }
                ctx.closePath();
                ctx.fillStyle = zone.color + Math.floor(alpha * 255).toString(16).padStart(2, '0');
                ctx.fill();
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
                ctx.lineWidth = 2;
                ctx.stroke();

                if (state.showLabels) {
                    drawLabel(zone.name, x, y, zone.color);
                }
            });
        }

        function drawViennaOverlay() {
            const centerX = canvas.width * 0.5;
            const centerY = canvas.height * 0.5;
            const baseRadius = Math.min(canvas.width, canvas.height) / 3;

            // Draw districts (simplified)
            ctx.strokeStyle = 'rgba(255, 100, 100, 0.3)';
            ctx.lineWidth = 2;

            // 1st district (CBD)
            ctx.beginPath();
            ctx.arc(centerX, centerY, baseRadius * 0.1, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(255, 100, 100, 0.15)';
            ctx.fill();
            ctx.stroke();

            // Gürtel (ring)
            ctx.beginPath();
            ctx.arc(centerX, centerY, baseRadius * 0.3, 0, Math.PI * 2);
            ctx.stroke();

            // S-Bahn lines
            ctx.strokeStyle = 'rgba(100, 200, 100, 0.3)';
            ctx.lineWidth = 1.5;
            ctx.setLineDash([3, 3]);
            for (let angle = 0; angle < Math.PI * 2; angle += Math.PI / 4) {
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(
                    centerX + Math.cos(angle) * baseRadius * 0.8,
                    centerY + Math.sin(angle) * baseRadius * 0.8
                );
                ctx.stroke();
            }
            ctx.setLineDash([]);

            // Outer ring
            ctx.strokeStyle = 'rgba(200, 200, 100, 0.3)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.arc(centerX, centerY, baseRadius * 0.7, 0, Math.PI * 2);
            ctx.stroke();

            ctx.font = 'bold 10px Inter';
            ctx.fillStyle = 'rgba(255, 150, 100, 0.6)';
            ctx.textAlign = 'center';
            ctx.fillText('WIEN', centerX - 30, centerY - 20);
        }

        function drawCommuterFlows() {
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const maxRadius = Math.min(canvas.width, canvas.height) / 2;

            // Draw animated arrows
            const time = Date.now() / 1000;
            const arrowCount = 12;

            for (let i = 0; i < arrowCount; i++) {
                const angle = (i / arrowCount) * Math.PI * 2;
                const distance = maxRadius * 0.7 * (1 - (time % 2) / 2);
                const thickness = Math.max(1, 8 - distance / maxRadius * 7);

                const startX = centerX + Math.cos(angle) * maxRadius * 0.8;
                const startY = centerY + Math.sin(angle) * maxRadius * 0.8;
                const endX = centerX + Math.cos(angle) * distance;
                const endY = centerY + Math.sin(angle) * distance;

                // Draw arrow line
                ctx.strokeStyle = `rgba(100, 200, 255, ${0.3 + 0.3 * Math.sin(time + i)})`;
                ctx.lineWidth = thickness;
                ctx.beginPath();
                ctx.moveTo(startX, startY);
                ctx.lineTo(endX, endY);
                ctx.stroke();

                // Draw arrowhead
                const headlen = 15;
                const angle2 = Math.atan2(centerY - startY, centerX - startX);
                ctx.fillStyle = `rgba(100, 200, 255, 0.5)`;
                ctx.beginPath();
                ctx.moveTo(endX, endY);
                ctx.lineTo(endX - headlen * Math.cos(angle2 - Math.PI / 6), endY - headlen * Math.sin(angle2 - Math.PI / 6));
                ctx.lineTo(endX - headlen * Math.cos(angle2 + Math.PI / 6), endY - headlen * Math.sin(angle2 + Math.PI / 6));
                ctx.closePath();
                ctx.fill();
            }
        }

        function drawLabel(text, x, y, color) {
            ctx.font = 'bold 11px Inter';
            ctx.fillStyle = color;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
            ctx.shadowBlur = 5;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;
            ctx.fillText(text, x, y);
            ctx.shadowColor = 'transparent';
        }

        function draw() {
            ctx.fillStyle = 'rgba(10, 10, 26, 0.1)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            if (state.model === 'burgess') {
                drawBurgessModel();
            } else if (state.model === 'hoyt') {
                drawHoytModel();
            } else if (state.model === 'harris') {
                drawHarrisUllmanModel();
            }

            if (state.showVienna) {
                drawViennaOverlay();
            }

            if (state.showCommuters) {
                drawCommuterFlows();
            }

            requestAnimationFrame(draw);
        }

        // Mouse handling
        function handleMouseMove(e) {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const maxRadius = Math.min(canvas.width, canvas.height) / 2.5;
            const growthFactor = getGrowthFactor(state.year);

            let hoveredZone = null;

            if (state.model === 'burgess') {
                const distance = Math.sqrt(Math.pow(x - centerX, 2) + Math.pow(y - centerY, 2));
                for (let i = zones.burgess.length - 1; i >= 0; i--) {
                    const radius = zones.burgess[i].radius * maxRadius * growthFactor;
                    const nextRadius = i < zones.burgess.length - 1
                        ? zones.burgess[i + 1].radius * maxRadius * growthFactor
                        : radius + maxRadius * 0.1;
                    if (distance < nextRadius) {
                        hoveredZone = zones.burgess[i];
                        break;
                    }
                }
            } else if (state.model === 'harris') {
                for (let i = zones.harris.length - 1; i >= 0; i--) {
                    const zone = zones.harris[i];
                    const zx = canvas.width * zone.x;
                    const zy = canvas.height * zone.y;
                    const radius = zone.size * Math.min(canvas.width, canvas.height) * growthFactor;
                    const distance = Math.sqrt(Math.pow(x - zx, 2) + Math.pow(y - zy, 2));
                    if (distance < radius * 1.3) {
                        hoveredZone = zone;
                        break;
                    }
                }
            }

            state.hoveredZone = hoveredZone;
            if (hoveredZone) {
                showTooltip(hoveredZone, e.clientX - rect.left, e.clientY - rect.top);
            } else {
                hideTooltip();
            }
        }

        function showTooltip(zone, x, y) {
            tooltip.innerHTML = `<div class="tooltip-title">${zone.name}</div><div>${zone.description}</div>`;
            tooltip.style.display = 'block';
            tooltip.style.left = (x + 10) + 'px';
            tooltip.style.top = (y + 10) + 'px';
        }

        function hideTooltip() {
            tooltip.style.display = 'none';
        }

        // Initial draw
        updateLegend();
    </script>
</body>
</html>
