<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Doppelspaltexperiment - Quantenphysik Interaktiv</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&display=swap');

        * { box-sizing: border-box; margin: 0; padding: 0; }

        body {
            font-family: 'Inter', -apple-system, sans-serif;
            background: linear-gradient(135deg, #05051a 0%, #0a0a2e 50%, #150530 100%);
            min-height: 100vh;
            color: #fff;
        }

        .container {
            max-width: 100%;
            padding: 12px;
        }

        header {
            text-align: center;
            margin-bottom: 12px;
        }

        h1 {
            font-size: 1.6em;
            font-weight: 700;
            background: linear-gradient(135deg, #ab47bc, #7c4dff, #00bcd4);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 4px;
        }

        .subtitle { color: rgba(255,255,255,0.5); font-size: 0.85em; }

        /* MAIN LAYOUT: Side by Side */
        .main-layout {
            display: grid;
            grid-template-columns: 1fr 320px;
            gap: 12px;
            height: calc(100vh - 80px);
            min-height: 500px;
        }

        @media (max-width: 900px) {
            .main-layout { grid-template-columns: 1fr; height: auto; }
        }

        /* LEFT SIDE: Simulation */
        .sim-panel {
            background: rgba(15, 15, 35, 0.9);
            border-radius: 12px;
            border: 1px solid rgba(171, 71, 188, 0.2);
            padding: 12px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        canvas#mainCanvas {
            width: 100%;
            flex: 1;
            min-height: 350px;
            border-radius: 8px;
            background: radial-gradient(ellipse at 20% 50%, #0a0a20 0%, #050510 100%);
            border: 1px solid rgba(171, 71, 188, 0.2);
        }

        /* Mode Selector - Compact */
        .mode-row {
            display: flex;
            gap: 6px;
            margin: 8px 0;
        }

        .mode-btn {
            flex: 1;
            padding: 8px;
            background: rgba(0,0,0,0.3);
            border: 2px solid transparent;
            border-radius: 6px;
            color: rgba(255,255,255,0.6);
            font-size: 0.75em;
            cursor: pointer;
            text-align: center;
        }

        .mode-btn:hover { background: rgba(255,255,255,0.05); }
        .mode-btn.active { border-color: #ab47bc; color: #ab47bc; background: rgba(171,71,188,0.15); }
        .mode-btn .icon { display: block; font-size: 1.2em; margin-bottom: 2px; }

        /* Intensity Graph - Compact */
        .intensity-row {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 0;
        }

        .intensity-label {
            font-size: 0.7em;
            color: rgba(255,255,255,0.5);
            white-space: nowrap;
        }

        #intensityCanvas {
            flex: 1;
            height: 50px;
            border-radius: 4px;
            background: rgba(0,0,0,0.3);
        }

        /* Collapsible Info */
        .info-toggle {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 10px;
            background: rgba(171, 71, 188, 0.1);
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.75em;
            color: #ab47bc;
            margin-top: 6px;
        }

        .info-toggle:hover { background: rgba(171, 71, 188, 0.2); }
        .info-content { display: none; padding: 10px; font-size: 0.8em; color: rgba(255,255,255,0.7); line-height: 1.5; }
        .info-toggle.open + .info-content { display: block; }

        /* RIGHT SIDE: Controls */
        .ctrl-panel {
            background: rgba(15, 15, 35, 0.9);
            border-radius: 12px;
            border: 1px solid rgba(171, 71, 188, 0.15);
            padding: 12px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .section-title {
            font-size: 0.65em;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            color: rgba(255,255,255,0.4);
            margin-bottom: 6px;
        }

        /* Particle Selector - Compact */
        .particle-row {
            display: flex;
            gap: 6px;
        }

        .particle-btn {
            flex: 1;
            padding: 8px;
            background: rgba(255,255,255,0.05);
            border: 2px solid rgba(255,255,255,0.1);
            border-radius: 8px;
            cursor: pointer;
            text-align: center;
            transition: all 0.2s;
        }

        .particle-btn:hover { background: rgba(255,255,255,0.1); }
        .particle-btn.active { border-color: #ab47bc; background: rgba(171,71,188,0.2); }
        .particle-btn .icon { font-size: 1.2em; }
        .particle-btn .name { font-size: 0.75em; display: block; margin-top: 2px; }

        /* Stats - Ultra Compact */
        .stats-row {
            display: flex;
            gap: 6px;
        }

        .stat-box {
            flex: 1;
            padding: 6px;
            background: rgba(255,255,255,0.03);
            border-radius: 6px;
            text-align: center;
        }

        .stat-val { font-size: 1.1em; font-weight: 700; color: #ab47bc; }
        .stat-lbl { font-size: 0.6em; color: rgba(255,255,255,0.4); text-transform: uppercase; }

        /* Sliders - Compact */
        .slider-item {
            padding: 8px;
            background: rgba(255,255,255,0.03);
            border-radius: 6px;
        }

        .slider-head {
            display: flex;
            justify-content: space-between;
            margin-bottom: 4px;
        }

        .slider-lbl { font-size: 0.75em; color: rgba(255,255,255,0.7); }
        .slider-val { font-size: 0.75em; font-weight: 600; color: #ab47bc; font-family: monospace; }

        input[type="range"] {
            width: 100%;
            height: 4px;
            -webkit-appearance: none;
            background: linear-gradient(90deg, #7c4dff, #ab47bc);
            border-radius: 2px;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            background: white;
            border-radius: 50%;
            cursor: pointer;
        }

        #wavelength {
            background: linear-gradient(90deg, #8b00ff, #0000ff, #00ffff, #00ff00, #ffff00, #ff7f00, #ff0000);
        }

        /* Toggles - Compact */
        .toggle-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 8px;
            background: rgba(255,255,255,0.03);
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.75em;
        }

        .toggle-item:hover { background: rgba(255,255,255,0.05); }

        .toggle-sw {
            width: 32px;
            height: 18px;
            background: rgba(255,255,255,0.2);
            border-radius: 9px;
            position: relative;
        }

        .toggle-sw::after {
            content: '';
            position: absolute;
            width: 14px;
            height: 14px;
            background: white;
            border-radius: 50%;
            top: 2px;
            left: 2px;
            transition: 0.2s;
        }

        .toggle-item.active .toggle-sw { background: #ab47bc; }
        .toggle-item.active .toggle-sw::after { left: 16px; }

        /* Buttons - Compact */
        .btn-row {
            display: flex;
            gap: 6px;
        }

        .btn {
            flex: 1;
            padding: 10px;
            border: none;
            border-radius: 8px;
            font-size: 0.8em;
            font-weight: 600;
            cursor: pointer;
        }

        .btn.primary { background: linear-gradient(135deg, #ab47bc, #7c4dff); color: white; }
        .btn.secondary { background: rgba(255,255,255,0.1); color: rgba(255,255,255,0.7); }
        .btn.detector { background: linear-gradient(135deg, #e74c3c, #c0392b); color: white; }
        .btn.detector.active { background: linear-gradient(135deg, #27ae60, #2ecc71); }

        /* Speed - Compact */
        .speed-row {
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 6px;
            background: rgba(0,0,0,0.2);
            border-radius: 6px;
        }

        .speed-lbl { font-size: 0.7em; color: rgba(255,255,255,0.5); margin-right: 4px; }

        .speed-btn {
            padding: 4px 8px;
            background: rgba(255,255,255,0.1);
            border: none;
            border-radius: 4px;
            color: white;
            font-size: 0.7em;
            cursor: pointer;
        }

        .speed-btn.active { background: #ab47bc; }

        /* Formula */
        .formula {
            text-align: center;
            padding: 8px;
            background: rgba(0,0,0,0.3);
            border-radius: 6px;
            font-family: monospace;
            font-size: 0.85em;
            color: #ab47bc;
        }

        /* Detector Alert */
        .detector-alert {
            display: none;
            padding: 8px;
            background: rgba(231, 76, 60, 0.15);
            border: 1px solid rgba(231, 76, 60, 0.3);
            border-radius: 6px;
            font-size: 0.75em;
        }

        .detector-alert.visible { display: block; }
        .detector-alert strong { color: #e74c3c; }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Doppelspaltexperiment</h1>
            <p class="subtitle">Welle-Teilchen-Dualismus: Interferenz durch √úberlagerung von Kugelwellen</p>
        </header>

        <div class="main-layout">
            <!-- LEFT: Simulation -->
            <div class="sim-panel">
                <canvas id="mainCanvas"></canvas>

                <div class="mode-row">
                    <button class="mode-btn active" data-mode="double">
                        <span class="icon">‚ïë‚ïë</span>Doppelspalt
                    </button>
                    <button class="mode-btn" data-mode="single">
                        <span class="icon">‚îÇ</span>Einzelspalt
                    </button>
                    <button class="mode-btn" data-mode="compare">
                        <span class="icon">‚ü∑</span>Vergleich
                    </button>
                </div>

                <div class="intensity-row">
                    <span class="intensity-label">üìä Intensit√§t</span>
                    <canvas id="intensityCanvas"></canvas>
                </div>

                <div class="detector-alert" id="detectorAlert">
                    <strong>üîç Detektor AKTIV:</strong> Interferenzmuster verschwindet ‚Äì die Messung zerst√∂rt die Wellennatur!
                </div>

                <div class="info-toggle" onclick="this.classList.toggle('open')">
                    üí° Huygens-Prinzip <span style="margin-left:auto">‚ñº</span>
                </div>
                <div class="info-content">
                    Jeder Punkt einer Wellenfront ist Ausgangspunkt einer neuen <strong>Kugelwelle</strong> (Elementarwelle).
                    Die √úberlagerung aller Elementarwellen ergibt die neue Wellenfront.
                    Bei zwei Spalten entstehen zwei Kugelwellen, die sich √ºberlagern und ein <strong>Interferenzmuster</strong> bilden.
                </div>

                <div class="info-toggle" onclick="this.classList.toggle('open')">
                    üìö Konstruktive & Destruktive Interferenz <span style="margin-left:auto">‚ñº</span>
                </div>
                <div class="info-content">
                    <strong>Konstruktiv (Maximum):</strong> Gangunterschied Œîs = n¬∑Œª ‚Üí Wellenberge treffen auf Wellenberge ‚Üí Verst√§rkung<br><br>
                    <strong>Destruktiv (Minimum):</strong> Gangunterschied Œîs = (n+¬Ω)¬∑Œª ‚Üí Wellenberg trifft Wellental ‚Üí Ausl√∂schung<br><br>
                    Die <strong>hellen Streifen</strong> entstehen dort, wo die Wellen sich verst√§rken, die <strong>dunklen Streifen</strong> dort, wo sie sich ausl√∂schen.
                </div>
            </div>

            <!-- RIGHT: Controls -->
            <div class="ctrl-panel">
                <div class="section-title">üî¨ Teilchenquelle</div>
                <div class="particle-row">
                    <button class="particle-btn active" data-particle="photon">
                        <span class="icon">üí°</span>
                        <span class="name">Photonen</span>
                    </button>
                    <button class="particle-btn" data-particle="electron">
                        <span class="icon">‚ö°</span>
                        <span class="name">Elektronen</span>
                    </button>
                </div>

                <div class="section-title">üìä Statistik</div>
                <div class="stats-row">
                    <div class="stat-box">
                        <div class="stat-val" id="totalCount">0</div>
                        <div class="stat-lbl">Gesamt</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-val" id="slit1Count">0</div>
                        <div class="stat-lbl">Spalt 1</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-val" id="slit2Count">0</div>
                        <div class="stat-lbl">Spalt 2</div>
                    </div>
                </div>

                <div class="section-title">‚öôÔ∏è Parameter</div>

                <div class="slider-item">
                    <div class="slider-head">
                        <span class="slider-lbl">üåà Wellenl√§nge Œª</span>
                        <span class="slider-val" id="wavelengthVal">550 nm</span>
                    </div>
                    <input type="range" id="wavelength" min="380" max="700" value="550">
                </div>

                <div class="slider-item">
                    <div class="slider-head">
                        <span class="slider-lbl">‚ÜîÔ∏è Spaltabstand d</span>
                        <span class="slider-val" id="slitDistanceVal">0.5 mm</span>
                    </div>
                    <input type="range" id="slitDistance" min="30" max="120" value="60">
                </div>

                <div class="slider-item">
                    <div class="slider-head">
                        <span class="slider-lbl">üìè Spaltbreite b</span>
                        <span class="slider-val" id="slitWidthVal">0.1 mm</span>
                    </div>
                    <input type="range" id="slitWidth" min="5" max="30" value="12">
                </div>

                <div class="slider-item">
                    <div class="slider-head">
                        <span class="slider-lbl">‚ö° Emissionsrate</span>
                        <span class="slider-val" id="rateVal">Mittel</span>
                    </div>
                    <input type="range" id="emissionRate" min="1" max="10" value="5">
                </div>

                <div class="section-title">üéõÔ∏è Optionen</div>

                <div class="toggle-item active" id="toggleWaves" onclick="toggleOption('waves')">
                    <div class="toggle-sw"></div>
                    <span>Wellenausbreitung zeigen</span>
                </div>

                <div class="toggle-item" id="toggleProbability" onclick="toggleOption('probability')">
                    <div class="toggle-sw"></div>
                    <span>Theoretische Intensit√§t</span>
                </div>

                <div class="btn-row">
                    <button class="btn primary" id="playBtn" onclick="togglePlay()">‚ñ∂ Start</button>
                    <button class="btn secondary" onclick="resetExperiment()">‚Ü∫ Reset</button>
                </div>

                <button class="btn detector" id="detectorBtn" onclick="toggleDetector()">
                    üîç Detektor AN
                </button>

                <div class="speed-row">
                    <span class="speed-lbl">Tempo:</span>
                    <button class="speed-btn" onclick="setSpeed(0.5)">0.5x</button>
                    <button class="speed-btn active" onclick="setSpeed(1)">1x</button>
                    <button class="speed-btn" onclick="setSpeed(2)">2x</button>
                    <button class="speed-btn" onclick="setSpeed(5)">5x</button>
                </div>

                <div class="formula">Œîy = Œª ¬∑ L / d</div>
            </div>
        </div>
    </div>

    <script>
        const mainCanvas = document.getElementById('mainCanvas');
        const ctx = mainCanvas.getContext('2d');
        const intensityCanvas = document.getElementById('intensityCanvas');
        const ictx = intensityCanvas.getContext('2d');

        // Resize canvases
        function resizeCanvases() {
            const simPanel = mainCanvas.parentElement;
            mainCanvas.width = simPanel.clientWidth - 24;
            mainCanvas.height = Math.min(450, simPanel.clientHeight - 200);
            intensityCanvas.width = intensityCanvas.offsetWidth;
            intensityCanvas.height = 50;
        }

        window.addEventListener('resize', resizeCanvases);
        setTimeout(resizeCanvases, 100);

        // Simulation state
        let isPlaying = false;
        let speed = 1;
        let mode = 'double';
        let particleType = 'photon';
        let detectorActive = false;
        let showWaves = true;
        let showProbability = false;

        // Physics parameters
        let wavelength = 550;
        let slitDistance = 60;
        let slitWidth = 12;
        let emissionRate = 5;

        // Particles and detection
        let particles = [];
        let detectedPoints = [];
        let histogram = new Array(200).fill(0);
        let totalCount = 0;
        let slit1Count = 0;
        let slit2Count = 0;

        let time = 0;

        // Dynamic geometry
        function getGeometry() {
            return {
                sourceX: mainCanvas.width * 0.08,
                slitX: mainCanvas.width * 0.35,
                screenX: mainCanvas.width * 0.88,
                centerY: mainCanvas.height / 2
            };
        }

        // Convert wavelength to RGB
        function wavelengthToColor(wl, alpha = 1) {
            let r, g, b;
            if (wl >= 380 && wl < 440) { r = -(wl - 440) / 60; g = 0; b = 1; }
            else if (wl < 490) { r = 0; g = (wl - 440) / 50; b = 1; }
            else if (wl < 510) { r = 0; g = 1; b = -(wl - 510) / 20; }
            else if (wl < 580) { r = (wl - 510) / 70; g = 1; b = 0; }
            else if (wl < 645) { r = 1; g = -(wl - 645) / 65; b = 0; }
            else { r = 1; g = 0; b = 0; }
            return `rgba(${Math.round(r * 255)}, ${Math.round(g * 255)}, ${Math.round(b * 255)}, ${alpha})`;
        }

        // Calculate interference intensity (physically correct)
        function getIntensity(y, slitMode = mode) {
            const geo = getGeometry();
            const d = slitDistance * 0.00001;  // convert to meters
            const b = slitWidth * 0.000003;    // convert to meters
            const L = 0.5;  // screen distance in meters
            const lambda = wavelength * 1e-9;  // wavelength in meters
            const yOffset = (y - geo.centerY) * 0.0001;  // position on screen
            const theta = Math.atan2(yOffset, L);
            const sinTheta = Math.sin(theta);

            // Single slit diffraction envelope
            const alpha = Math.PI * b * sinTheta / lambda;
            const singleSlit = alpha !== 0 ? Math.pow(Math.sin(alpha) / alpha, 2) : 1;

            if (slitMode === 'single' || detectorActive) return singleSlit;

            // Double slit interference
            const beta = Math.PI * d * sinTheta / lambda;
            return singleSlit * Math.pow(Math.cos(beta), 2);
        }

        // Emit particle
        function emitParticle() {
            const geo = getGeometry();
            const color = particleType === 'photon' ? wavelengthToColor(wavelength) : 'rgba(66, 165, 245, 1)';

            // Use rejection sampling based on intensity distribution
            let y, attempts = 0;
            do {
                y = geo.centerY + (Math.random() - 0.5) * (mainCanvas.height * 0.9);
                if (Math.random() < getIntensity(y)) break;
                attempts++;
            } while (attempts < 200);

            particles.push({
                x: geo.sourceX,
                y: geo.centerY,
                targetY: y,
                color: color,
                slit: Math.random() < 0.5 ? 1 : 2,
                phase: time,
                active: true
            });
        }

        // Update particles
        function updateParticles() {
            const geo = getGeometry();
            const moveSpeed = 4 * speed;

            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];

                if (p.x < geo.slitX) {
                    p.x += moveSpeed;
                } else if (p.x < geo.screenX) {
                    p.x += moveSpeed;
                    const progress = (p.x - geo.slitX) / (geo.screenX - geo.slitX);
                    p.y = geo.centerY + (p.targetY - geo.centerY) * progress;
                } else {
                    // Particle hits screen
                    detectedPoints.push({
                        x: geo.screenX + 3 + Math.random() * 8,
                        y: Math.round(p.y),
                        color: p.color,
                        age: 0
                    });

                    const histIdx = Math.floor((p.y / mainCanvas.height) * histogram.length);
                    if (histIdx >= 0 && histIdx < histogram.length) histogram[histIdx]++;

                    totalCount++;
                    if (p.slit === 1) slit1Count++; else slit2Count++;
                    updateStats();
                    particles.splice(i, 1);
                }
            }
        }

        function updateStats() {
            document.getElementById('totalCount').textContent = totalCount;
            document.getElementById('slit1Count').textContent = slit1Count;
            document.getElementById('slit2Count').textContent = slit2Count;
        }

        // Draw circular wavefronts with interference
        function drawWavefronts() {
            const geo = getGeometry();
            const waveColor = particleType === 'photon' ? wavelengthToColor(wavelength, 1) : 'rgba(66, 165, 245, 1)';
            const waveSpeed = 2 * speed;
            const numWaves = 15;
            const waveSpacing = wavelength / 15;  // Scale wavelength to visual spacing

            const slit1Y = geo.centerY - slitDistance;
            const slit2Y = geo.centerY + slitDistance;

            // Create offscreen canvas for interference pattern
            const offCanvas = document.createElement('canvas');
            offCanvas.width = mainCanvas.width;
            offCanvas.height = mainCanvas.height;
            const offCtx = offCanvas.getContext('2d');

            // Draw interference pattern using wave superposition
            const imageData = offCtx.createImageData(mainCanvas.width, mainCanvas.height);
            const data = imageData.data;

            const startX = geo.slitX + 10;
            const endX = geo.screenX - 5;

            for (let px = startX; px < endX; px++) {
                for (let py = 0; py < mainCanvas.height; py++) {
                    // Distance from each slit
                    const d1 = Math.sqrt((px - geo.slitX) ** 2 + (py - slit1Y) ** 2);
                    const d2 = Math.sqrt((px - geo.slitX) ** 2 + (py - slit2Y) ** 2);

                    // Phase of wave from each slit (including time animation)
                    const phase1 = (d1 / waveSpacing - time * waveSpeed * 0.1) * 2 * Math.PI;
                    const phase2 = (d2 / waveSpacing - time * waveSpeed * 0.1) * 2 * Math.PI;

                    let amplitude;
                    if (mode === 'single' || detectorActive) {
                        // Single slit: only one wave
                        const dCenter = Math.sqrt((px - geo.slitX) ** 2 + (py - geo.centerY) ** 2);
                        const phaseCenter = (dCenter / waveSpacing - time * waveSpeed * 0.1) * 2 * Math.PI;
                        amplitude = Math.cos(phaseCenter);
                    } else {
                        // Double slit: superposition of two waves
                        const wave1 = Math.cos(phase1);
                        const wave2 = Math.cos(phase2);
                        amplitude = (wave1 + wave2) / 2;
                    }

                    // Convert amplitude to brightness (intensity = amplitude^2, but show amplitude for visibility)
                    const brightness = (amplitude + 1) / 2;  // Map -1..1 to 0..1
                    const alpha = brightness * 0.4;

                    const idx = (py * mainCanvas.width + px) * 4;
                    if (particleType === 'photon') {
                        const rgb = wavelengthToRGB(wavelength);
                        data[idx] = rgb.r;
                        data[idx + 1] = rgb.g;
                        data[idx + 2] = rgb.b;
                    } else {
                        data[idx] = 66;
                        data[idx + 1] = 165;
                        data[idx + 2] = 245;
                    }
                    data[idx + 3] = alpha * 255;
                }
            }

            offCtx.putImageData(imageData, 0, 0);
            ctx.drawImage(offCanvas, 0, 0);

            // Draw concentric circles from each slit for clarity
            ctx.strokeStyle = waveColor.replace(/[\d.]+\)$/g, '0.3)');
            ctx.lineWidth = 1;

            for (let r = 0; r < 400; r += waveSpacing) {
                const radius = r + (time * waveSpeed * 3) % waveSpacing;

                if (mode !== 'single' && !detectorActive) {
                    // Two slits
                    ctx.beginPath();
                    ctx.arc(geo.slitX, slit1Y, radius, -Math.PI/2, Math.PI/2);
                    ctx.stroke();

                    ctx.beginPath();
                    ctx.arc(geo.slitX, slit2Y, radius, -Math.PI/2, Math.PI/2);
                    ctx.stroke();
                } else {
                    // Single slit
                    ctx.beginPath();
                    ctx.arc(geo.slitX, geo.centerY, radius, -Math.PI/2, Math.PI/2);
                    ctx.stroke();
                }
            }
        }

        function wavelengthToRGB(wl) {
            let r, g, b;
            if (wl >= 380 && wl < 440) { r = -(wl - 440) / 60; g = 0; b = 1; }
            else if (wl < 490) { r = 0; g = (wl - 440) / 50; b = 1; }
            else if (wl < 510) { r = 0; g = 1; b = -(wl - 510) / 20; }
            else if (wl < 580) { r = (wl - 510) / 70; g = 1; b = 0; }
            else if (wl < 645) { r = 1; g = -(wl - 645) / 65; b = 0; }
            else { r = 1; g = 0; b = 0; }
            return { r: Math.round(r * 255), g: Math.round(g * 255), b: Math.round(b * 255) };
        }

        // Draw functions
        function draw() {
            const geo = getGeometry();

            // Background
            ctx.fillStyle = '#0a0a18';
            ctx.fillRect(0, 0, mainCanvas.width, mainCanvas.height);

            // Grid
            ctx.strokeStyle = 'rgba(171, 71, 188, 0.03)';
            for (let x = 0; x < mainCanvas.width; x += 40) {
                ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, mainCanvas.height); ctx.stroke();
            }

            // Wave fronts with interference
            if (showWaves && isPlaying) {
                drawWavefronts();
            }

            // Source glow
            const srcColor = particleType === 'photon' ? wavelengthToColor(wavelength) : '#42a5f5';
            const glow = ctx.createRadialGradient(geo.sourceX, geo.centerY, 0, geo.sourceX, geo.centerY, 30);
            glow.addColorStop(0, srcColor.replace('1)', '0.4)'));
            glow.addColorStop(1, 'transparent');
            ctx.fillStyle = glow;
            ctx.beginPath(); ctx.arc(geo.sourceX, geo.centerY, 30, 0, Math.PI * 2); ctx.fill();
            ctx.beginPath(); ctx.arc(geo.sourceX, geo.centerY, 10, 0, Math.PI * 2);
            ctx.fillStyle = srcColor; ctx.fill();

            // Incoming plane wave (before slits)
            if (showWaves && isPlaying) {
                ctx.strokeStyle = srcColor.replace('1)', '0.2)');
                ctx.lineWidth = 2;
                const waveSpacing = wavelength / 15;
                for (let x = geo.sourceX + 20; x < geo.slitX - 5; x += waveSpacing) {
                    const xPos = x + (time * speed * 6) % waveSpacing;
                    if (xPos < geo.slitX - 5) {
                        ctx.beginPath();
                        ctx.moveTo(xPos, geo.centerY - 60);
                        ctx.lineTo(xPos, geo.centerY + 60);
                        ctx.stroke();
                    }
                }
            }

            // Barrier with slits
            const slit1Y = geo.centerY - slitDistance;
            const slit2Y = geo.centerY + slitDistance;
            const hw = slitWidth / 2;

            ctx.fillStyle = '#1a1a2e';
            ctx.strokeStyle = '#3a3a5e';
            ctx.lineWidth = 1;

            if (mode === 'single' || (mode === 'compare' && detectorActive)) {
                // Single slit
                ctx.fillRect(geo.slitX - 8, 0, 16, geo.centerY - hw);
                ctx.fillRect(geo.slitX - 8, geo.centerY + hw, 16, mainCanvas.height);
                ctx.strokeRect(geo.slitX - 8, 0, 16, geo.centerY - hw);
                ctx.strokeRect(geo.slitX - 8, geo.centerY + hw, 16, mainCanvas.height);
            } else {
                // Double slit
                ctx.fillRect(geo.slitX - 8, 0, 16, slit1Y - hw);
                ctx.fillRect(geo.slitX - 8, slit1Y + hw, 16, slit2Y - slit1Y - slitWidth);
                ctx.fillRect(geo.slitX - 8, slit2Y + hw, 16, mainCanvas.height);
                ctx.strokeRect(geo.slitX - 8, 0, 16, slit1Y - hw);
                ctx.strokeRect(geo.slitX - 8, slit1Y + hw, 16, slit2Y - slit1Y - slitWidth);
                ctx.strokeRect(geo.slitX - 8, slit2Y + hw, 16, mainCanvas.height);
            }

            // Slit openings highlighted
            ctx.strokeStyle = '#ab47bc';
            ctx.lineWidth = 3;
            ctx.shadowColor = '#ab47bc';
            ctx.shadowBlur = 10;
            if (mode === 'single') {
                ctx.beginPath(); ctx.moveTo(geo.slitX, geo.centerY - hw); ctx.lineTo(geo.slitX, geo.centerY + hw); ctx.stroke();
            } else {
                ctx.beginPath(); ctx.moveTo(geo.slitX, slit1Y - hw); ctx.lineTo(geo.slitX, slit1Y + hw); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(geo.slitX, slit2Y - hw); ctx.lineTo(geo.slitX, slit2Y + hw); ctx.stroke();
            }
            ctx.shadowBlur = 0;

            // Theoretical probability distribution on screen
            if (showProbability) {
                for (let y = 0; y < mainCanvas.height; y += 2) {
                    const intensity = getIntensity(y);
                    ctx.fillStyle = particleType === 'photon'
                        ? wavelengthToColor(wavelength, intensity * 0.5)
                        : `rgba(66, 165, 245, ${intensity * 0.5})`;
                    ctx.fillRect(geo.screenX, y, 15, 2);
                }
            }

            // Detection screen
            ctx.fillStyle = '#0f0f1a';
            ctx.fillRect(geo.screenX + 15, 0, mainCanvas.width - geo.screenX - 15, mainCanvas.height);
            ctx.strokeStyle = 'rgba(171, 71, 188, 0.3)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(geo.screenX + 15, 0);
            ctx.lineTo(geo.screenX + 15, mainCanvas.height);
            ctx.stroke();

            // Detected points (accumulated hits)
            detectedPoints.forEach(pt => {
                ctx.beginPath();
                ctx.arc(pt.x, pt.y, 2, 0, Math.PI * 2);
                const alpha = Math.max(0.3, 1 - pt.age * 0.001);
                ctx.fillStyle = pt.color.replace(/[\d.]+\)$/g, `${alpha})`);
                ctx.fill();
                pt.age++;
            });

            // Flying particles
            particles.forEach(p => {
                const glow = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, 15);
                glow.addColorStop(0, p.color);
                glow.addColorStop(1, 'transparent');
                ctx.fillStyle = glow;
                ctx.beginPath(); ctx.arc(p.x, p.y, 15, 0, Math.PI * 2); ctx.fill();
                ctx.beginPath(); ctx.arc(p.x, p.y, 4, 0, Math.PI * 2);
                ctx.fillStyle = '#fff'; ctx.fill();
            });

            // Labels
            ctx.fillStyle = 'rgba(255,255,255,0.6)';
            ctx.font = '11px Inter';
            ctx.textAlign = 'center';
            ctx.fillText(particleType === 'photon' ? 'Lichtquelle' : 'e‚Åª Quelle', geo.sourceX, geo.centerY + 55);
            ctx.fillText(mode === 'single' ? 'Einzelspalt' : 'Doppelspalt', geo.slitX, 20);
            ctx.fillText('Schirm', geo.screenX + 30, 20);

            // Slit labels
            if (mode !== 'single') {
                ctx.font = '10px Inter';
                ctx.fillStyle = 'rgba(171, 71, 188, 0.8)';
                ctx.fillText('Spalt 1', geo.slitX + 25, slit1Y);
                ctx.fillText('Spalt 2', geo.slitX + 25, slit2Y);
            }

            // Show interference maxima/minima markers on screen (if enough data)
            if (totalCount > 50 && mode !== 'single' && !detectorActive) {
                ctx.fillStyle = 'rgba(0, 255, 100, 0.6)';
                ctx.font = '9px Inter';
                ctx.textAlign = 'left';
                // Main maximum at center
                ctx.fillText('Max (0)', geo.screenX + 20, geo.centerY + 3);
            }
        }

        function drawIntensityGraph() {
            ictx.clearRect(0, 0, intensityCanvas.width, intensityCanvas.height);
            ictx.fillStyle = 'rgba(0,0,0,0.5)';
            ictx.fillRect(0, 0, intensityCanvas.width, intensityCanvas.height);

            // Draw theoretical curve
            ictx.strokeStyle = 'rgba(171, 71, 188, 0.4)';
            ictx.lineWidth = 1;
            ictx.beginPath();
            for (let i = 0; i < intensityCanvas.width; i++) {
                const y = (i / intensityCanvas.width) * mainCanvas.height;
                const intensity = getIntensity(y);
                const h = intensity * (intensityCanvas.height - 5);
                if (i === 0) ictx.moveTo(i, intensityCanvas.height - h);
                else ictx.lineTo(i, intensityCanvas.height - h);
            }
            ictx.stroke();

            if (totalCount === 0) return;

            // Draw histogram
            const maxVal = Math.max(...histogram, 1);
            const barWidth = intensityCanvas.width / histogram.length;
            const color = particleType === 'photon' ? wavelengthToColor(wavelength, 0.8) : 'rgba(66, 165, 245, 0.8)';
            ictx.fillStyle = color;

            for (let i = 0; i < histogram.length; i++) {
                const height = (histogram[i] / maxVal) * (intensityCanvas.height - 5);
                ictx.fillRect(i * barWidth, intensityCanvas.height - height, barWidth - 1, height);
            }
        }

        function animate() {
            if (isPlaying) {
                if (Math.random() < emissionRate * speed * 0.025) emitParticle();
                updateParticles();
                time++;
            }
            draw();
            drawIntensityGraph();
            requestAnimationFrame(animate);
        }

        // Controls
        function togglePlay() {
            isPlaying = !isPlaying;
            document.getElementById('playBtn').textContent = isPlaying ? '‚è∏ Pause' : '‚ñ∂ Start';
        }

        function resetExperiment() {
            particles = [];
            detectedPoints = [];
            histogram = new Array(200).fill(0);
            totalCount = slit1Count = slit2Count = 0;
            updateStats();
        }

        function toggleDetector() {
            detectorActive = !detectorActive;
            const btn = document.getElementById('detectorBtn');
            btn.textContent = detectorActive ? 'üîç Detektor AUS' : 'üîç Detektor AN';
            btn.classList.toggle('active', detectorActive);
            document.getElementById('detectorAlert').classList.toggle('visible', detectorActive);
            resetExperiment();
        }

        function toggleOption(opt) {
            if (opt === 'waves') {
                showWaves = !showWaves;
                document.getElementById('toggleWaves').classList.toggle('active', showWaves);
            } else {
                showProbability = !showProbability;
                document.getElementById('toggleProbability').classList.toggle('active', showProbability);
            }
        }

        function setSpeed(s) {
            speed = s;
            document.querySelectorAll('.speed-btn').forEach(btn => {
                btn.classList.toggle('active', parseFloat(btn.textContent) === s);
            });
        }

        function setMode(newMode) {
            mode = newMode;
            resetExperiment();
        }

        // Event Listeners
        document.querySelectorAll('.mode-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                setMode(btn.dataset.mode);
            });
        });

        document.querySelectorAll('.particle-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.particle-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                particleType = btn.dataset.particle;
                resetExperiment();
            });
        });

        document.getElementById('wavelength').addEventListener('input', e => {
            wavelength = parseInt(e.target.value);
            document.getElementById('wavelengthVal').textContent = wavelength + ' nm';
        });

        document.getElementById('slitDistance').addEventListener('input', e => {
            slitDistance = parseInt(e.target.value);
            document.getElementById('slitDistanceVal').textContent = (slitDistance * 0.01).toFixed(2) + ' mm';
        });

        document.getElementById('slitWidth').addEventListener('input', e => {
            slitWidth = parseInt(e.target.value);
            document.getElementById('slitWidthVal').textContent = (slitWidth * 0.01).toFixed(2) + ' mm';
        });

        document.getElementById('emissionRate').addEventListener('input', e => {
            emissionRate = parseInt(e.target.value);
            const labels = ['Minimal', 'Langsam', 'Langsam', 'Mittel', 'Mittel', 'Schnell', 'Schnell', 'Sehr schnell', 'Sehr schnell', 'Maximum'];
            document.getElementById('rateVal').textContent = labels[emissionRate - 1];
        });

        // Init
        resizeCanvases();
        animate();
    </script>
</body>
</html>
