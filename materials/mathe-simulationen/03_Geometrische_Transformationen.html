<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Geometrische Transformationen</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #0a0a1a 0%, #1a103d 50%, #2d1060 100%);
            color: #ffffff;
            height: 100vh;
            overflow: hidden;
        }

        .container {
            display: grid;
            grid-template-columns: 1fr 280px;
            height: 100vh;
            gap: 16px;
            padding: 16px;
        }

        .canvas-container {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .header {
            max-height: 40px;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        .header h1 {
            font-size: 24px;
            font-weight: 700;
            color: #00e5ff;
        }

        .header p {
            font-size: 0.75em;
            color: #a0a0ff;
            font-weight: 300;
        }

        canvas {
            flex: 1;
            min-height: 0;
            background: rgba(10, 10, 26, 0.4);
            border-radius: 12px;
            border: 1px solid rgba(0, 229, 255, 0.1);
            cursor: crosshair;
        }

        .controls-panel {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 16px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            overflow-y: auto;
            max-height: 100vh;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .control-label {
            font-size: 0.75em;
            font-weight: 600;
            color: #00e5ff;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        select, input[type="range"] {
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(0, 229, 255, 0.3);
            color: #ffffff;
            border-radius: 6px;
            padding: 8px 10px;
            font-size: 0.75em;
            font-family: 'Inter', sans-serif;
            cursor: pointer;
        }

        select:hover, input[type="range"]:hover {
            border-color: rgba(0, 229, 255, 0.6);
            background: rgba(255, 255, 255, 0.12);
        }

        select:focus, input[type="range"]:focus {
            outline: none;
            border-color: #00e5ff;
            box-shadow: 0 0 8px rgba(0, 229, 255, 0.4);
        }

        select option {
            background: #1a103d;
            color: #ffffff;
        }

        input[type="range"] {
            width: 100%;
            padding: 6px 0;
            height: 4px;
            -webkit-appearance: none;
            appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #00e5ff;
            cursor: pointer;
            box-shadow: 0 0 8px rgba(0, 229, 255, 0.5);
        }

        input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #00e5ff;
            cursor: pointer;
            border: none;
            box-shadow: 0 0 8px rgba(0, 229, 255, 0.5);
        }

        .value-display {
            font-size: 0.7em;
            color: #a0a0ff;
            text-align: center;
            padding: 4px;
            background: rgba(0, 229, 255, 0.05);
            border-radius: 4px;
        }

        .toggle-group {
            display: flex;
            gap: 8px;
        }

        .toggle-btn {
            flex: 1;
            padding: 8px 10px;
            font-size: 0.75em;
            font-weight: 600;
            border: 1px solid rgba(0, 229, 255, 0.3);
            background: rgba(255, 255, 255, 0.05);
            color: #ffffff;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            text-transform: uppercase;
        }

        .toggle-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(0, 229, 255, 0.6);
        }

        .toggle-btn.active {
            background: #00e5ff;
            color: #0a0a1a;
            border-color: #00e5ff;
            box-shadow: 0 0 12px rgba(0, 229, 255, 0.5);
        }

        button.reset-btn {
            width: 100%;
            padding: 10px;
            font-size: 0.75em;
            font-weight: 600;
            border: 1px solid rgba(124, 77, 255, 0.3);
            background: rgba(124, 77, 255, 0.1);
            color: #7c4dff;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        button.reset-btn:hover {
            background: rgba(124, 77, 255, 0.2);
            border-color: #7c4dff;
            box-shadow: 0 0 8px rgba(124, 77, 255, 0.4);
        }

        button.reset-btn:active {
            transform: scale(0.98);
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="canvas-container">
            <div class="header">
                <h1>Geometrische Transformationen</h1>
                <p>Spiegelung, Drehung, Verschiebung</p>
            </div>
            <canvas id="canvas"></canvas>
        </div>

        <div class="controls-panel">
            <div class="control-group">
                <label class="control-label">Figur</label>
                <select id="shapeSelect">
                    <option value="triangle">Dreieck</option>
                    <option value="square">Quadrat</option>
                    <option value="lshape">L-Form</option>
                    <option value="arrow">Pfeil</option>
                </select>
            </div>

            <div class="control-group">
                <label class="control-label">Transformation</label>
                <select id="transformSelect">
                    <option value="reflection">Spiegelung</option>
                    <option value="rotation">Drehung</option>
                    <option value="translation">Verschiebung</option>
                    <option value="scaling">Skalierung</option>
                </select>
            </div>

            <div id="reflectionControls" class="control-group" style="display: none;">
                <label class="control-label">Achse</label>
                <select id="reflectionAxis">
                    <option value="x">x-Achse</option>
                    <option value="y">y-Achse</option>
                    <option value="diag1">y = x</option>
                    <option value="diag2">y = -x</option>
                </select>
            </div>

            <div id="rotationControls" class="control-group" style="display: none;">
                <label class="control-label">Winkel</label>
                <input type="range" id="rotationAngle" min="0" max="360" step="15" value="45">
                <div class="value-display" id="rotationDisplay">45°</div>
                <label class="control-label" style="margin-top: 6px;">Zentrum</label>
                <div class="value-display">(0 | 0)</div>
            </div>

            <div id="translationControls" class="control-group" style="display: none;">
                <label class="control-label">Δx (Verschiebung X)</label>
                <input type="range" id="translationX" min="-8" max="8" step="0.5" value="2">
                <div class="value-display" id="translationXDisplay">2,00</div>

                <label class="control-label" style="margin-top: 6px;">Δy (Verschiebung Y)</label>
                <input type="range" id="translationY" min="-8" max="8" step="0.5" value="2">
                <div class="value-display" id="translationYDisplay">2,00</div>
            </div>

            <div id="scalingControls" class="control-group" style="display: none;">
                <label class="control-label">Faktor</label>
                <input type="range" id="scalingFactor" min="0.5" max="3" step="0.1" value="1.5">
                <div class="value-display" id="scalingDisplay">1,50</div>
            </div>

            <div class="control-group">
                <label class="control-label">Animation</label>
                <div class="toggle-group">
                    <button class="toggle-btn" id="animToggle">Aus</button>
                </div>
            </div>

            <button class="reset-btn" id="resetBtn">Zurücksetzen</button>
        </div>
    </div>

    <script>
        // ============================================
        // STATE & CONFIGURATION
        // ============================================
        const state = {
            shape: 'triangle',
            transform: 'reflection',
            reflectionAxis: 'x',
            rotationAngle: 45,
            translationX: 2,
            translationY: 2,
            scalingFactor: 1.5,
            animationEnabled: false,
            animationProgress: 1,
        };

        const config = {
            gridSize: 1,
            gridColor: 'rgba(255, 255, 255, 0.05)',
            axisColor: 'rgba(0, 229, 255, 0.3)',
            originalColor: '#00e5ff',
            transformedColor: '#7c4dff',
            labelSize: 11,
            labelColor: '#ffffff',
        };

        // ============================================
        // CANVAS SETUP
        // ============================================
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let dpr = window.devicePixelRatio || 1;

        function resizeCanvas() {
            const rect = canvas.getBoundingClientRect();
            const width = rect.width;
            const height = rect.height;

            canvas.width = width * dpr;
            canvas.height = height * dpr;
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';

            ctx.scale(dpr, dpr);
            ctx.font = `400 ${config.labelSize}px Inter, sans-serif`;
        }

        window.addEventListener('resize', () => {
            setTimeout(resizeCanvas, 50);
        });

        resizeCanvas();

        // ============================================
        // SHAPE DEFINITIONS
        // ============================================
        const shapes = {
            triangle: [
                { x: -2, y: 2 },
                { x: 2, y: 2 },
                { x: 0, y: -2 }
            ],
            square: [
                { x: -2, y: -2 },
                { x: 2, y: -2 },
                { x: 2, y: 2 },
                { x: -2, y: 2 }
            ],
            lshape: [
                { x: -2, y: -2 },
                { x: 2, y: -2 },
                { x: 2, y: 0 },
                { x: 0, y: 0 },
                { x: 0, y: 2 },
                { x: -2, y: 2 }
            ],
            arrow: [
                { x: 0, y: -2.5 },
                { x: 1, y: -0.5 },
                { x: 0.4, y: -0.5 },
                { x: 0.4, y: 2 },
                { x: -0.4, y: 2 },
                { x: -0.4, y: -0.5 },
                { x: -1, y: -0.5 }
            ]
        };

        // ============================================
        // COORDINATE SYSTEM UTILITIES
        // ============================================
        function getCanvasDimensions() {
            return {
                width: canvas.width / dpr,
                height: canvas.height / dpr,
                centerX: (canvas.width / dpr) / 2,
                centerY: (canvas.height / dpr) / 2
            };
        }

        function getGridScale() {
            const dim = getCanvasDimensions();
            const gridPixels = 40;
            return gridPixels / config.gridSize;
        }

        function worldToCanvas(x, y) {
            const dim = getCanvasDimensions();
            const scale = getGridScale();
            return {
                x: dim.centerX + x * scale,
                y: dim.centerY - y * scale
            };
        }

        function canvasToWorld(x, y) {
            const dim = getCanvasDimensions();
            const scale = getGridScale();
            return {
                x: (x - dim.centerX) / scale,
                y: (dim.centerY - y) / scale
            };
        }

        // ============================================
        // TRANSFORMATION FUNCTIONS
        // ============================================
        function reflectPoint(point, axis) {
            const p = { ...point };
            switch (axis) {
                case 'x':
                    p.y = -p.y;
                    break;
                case 'y':
                    p.x = -p.x;
                    break;
                case 'diag1':
                    [p.x, p.y] = [p.y, p.x];
                    break;
                case 'diag2':
                    [p.x, p.y] = [-p.y, -p.x];
                    break;
            }
            return p;
        }

        function rotatePoint(point, angle, centerX = 0, centerY = 0) {
            const rad = (angle * Math.PI) / 180;
            const cos = Math.cos(rad);
            const sin = Math.sin(rad);
            const x = point.x - centerX;
            const y = point.y - centerY;
            return {
                x: x * cos - y * sin + centerX,
                y: x * sin + y * cos + centerY
            };
        }

        function translatePoint(point, dx, dy) {
            return {
                x: point.x + dx,
                y: point.y + dy
            };
        }

        function scalePoint(point, factor, centerX = 0, centerY = 0) {
            return {
                x: centerX + (point.x - centerX) * factor,
                y: centerY + (point.y - centerY) * factor
            };
        }

        function transformShape(shape, progress) {
            const prog = Math.min(progress, 1);

            if (state.transform === 'reflection') {
                return shape.map(p => reflectPoint(p, state.reflectionAxis));
            } else if (state.transform === 'rotation') {
                const angle = state.rotationAngle * prog;
                return shape.map(p => rotatePoint(p, angle, 0, 0));
            } else if (state.transform === 'translation') {
                const dx = state.translationX * prog;
                const dy = state.translationY * prog;
                return shape.map(p => translatePoint(p, dx, dy));
            } else if (state.transform === 'scaling') {
                const factor = 1 + (state.scalingFactor - 1) * prog;
                return shape.map(p => scalePoint(p, factor, 0, 0));
            }
            return shape;
        }

        // ============================================
        // DRAWING FUNCTIONS
        // ============================================
        function drawGrid() {
            const dim = getCanvasDimensions();
            const scale = getGridScale();
            const minX = Math.floor(-dim.centerX / scale) - 1;
            const maxX = Math.ceil((dim.width - dim.centerX) / scale) + 1;
            const minY = Math.floor(-dim.centerY / scale) - 1;
            const maxY = Math.ceil((dim.height - dim.centerY) / scale) + 1;

            ctx.strokeStyle = config.gridColor;
            ctx.lineWidth = 1;

            for (let x = minX; x <= maxX; x++) {
                const canvasX = worldToCanvas(x, 0).x;
                ctx.beginPath();
                ctx.moveTo(canvasX, 0);
                ctx.lineTo(canvasX, dim.height);
                ctx.stroke();
            }

            for (let y = minY; y <= maxY; y++) {
                const canvasY = worldToCanvas(0, y).y;
                ctx.beginPath();
                ctx.moveTo(0, canvasY);
                ctx.lineTo(dim.width, canvasY);
                ctx.stroke();
            }
        }

        function drawAxes() {
            const dim = getCanvasDimensions();
            ctx.strokeStyle = config.axisColor;
            ctx.lineWidth = 2;

            const centerCanvas = worldToCanvas(0, 0);
            ctx.beginPath();
            ctx.moveTo(0, centerCanvas.y);
            ctx.lineTo(dim.width, centerCanvas.y);
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(centerCanvas.x, 0);
            ctx.lineTo(centerCanvas.x, dim.height);
            ctx.stroke();

            ctx.fillStyle = config.axisColor;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';
            ctx.font = `400 ${config.labelSize - 2}px Inter, sans-serif`;
            ctx.fillText('0', centerCanvas.x, centerCanvas.y + 4);
        }

        function drawReflectionAxis() {
            if (state.transform !== 'reflection') return;

            const dim = getCanvasDimensions();
            const scale = getGridScale();
            const axis = state.reflectionAxis;

            ctx.strokeStyle = 'rgba(0, 229, 255, 0.4)';
            ctx.lineWidth = 1.5;
            ctx.setLineDash([6, 4]);

            if (axis === 'x') {
                const y = worldToCanvas(0, 0).y;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(dim.width, y);
                ctx.stroke();
            } else if (axis === 'y') {
                const x = worldToCanvas(0, 0).x;
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, dim.height);
                ctx.stroke();
            } else if (axis === 'diag1') {
                const maxVal = Math.max(dim.width, dim.height) / getGridScale();
                const p1 = worldToCanvas(-maxVal, -maxVal);
                const p2 = worldToCanvas(maxVal, maxVal);
                ctx.beginPath();
                ctx.moveTo(p1.x, p1.y);
                ctx.lineTo(p2.x, p2.y);
                ctx.stroke();
            } else if (axis === 'diag2') {
                const maxVal = Math.max(dim.width, dim.height) / getGridScale();
                const p1 = worldToCanvas(-maxVal, maxVal);
                const p2 = worldToCanvas(maxVal, -maxVal);
                ctx.beginPath();
                ctx.moveTo(p1.x, p1.y);
                ctx.lineTo(p2.x, p2.y);
                ctx.stroke();
            }

            ctx.setLineDash([]);
        }

        function drawRotationCenter() {
            if (state.transform !== 'rotation') return;

            const centerPos = worldToCanvas(0, 0);
            const radius = 5;

            ctx.strokeStyle = 'rgba(0, 229, 255, 0.6)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.arc(centerPos.x, centerPos.y, radius, 0, Math.PI * 2);
            ctx.stroke();

            ctx.strokeStyle = 'rgba(0, 229, 255, 0.6)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(centerPos.x - 8, centerPos.y);
            ctx.lineTo(centerPos.x + 8, centerPos.y);
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(centerPos.x, centerPos.y - 8);
            ctx.lineTo(centerPos.x, centerPos.y + 8);
            ctx.stroke();
        }

        function drawTranslationVector() {
            if (state.transform !== 'translation') return;

            const originalShape = shapes[state.shape];
            if (originalShape.length === 0) return;

            const centerOriginal = {
                x: originalShape.reduce((sum, p) => sum + p.x, 0) / originalShape.length,
                y: originalShape.reduce((sum, p) => sum + p.y, 0) / originalShape.length
            };

            const translated = translatePoint(
                centerOriginal,
                state.translationX * state.animationProgress,
                state.translationY * state.animationProgress
            );

            const fromCanvas = worldToCanvas(centerOriginal.x, centerOriginal.y);
            const toCanvas = worldToCanvas(translated.x, translated.y);

            ctx.strokeStyle = 'rgba(0, 229, 255, 0.5)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(fromCanvas.x, fromCanvas.y);
            ctx.lineTo(toCanvas.x, toCanvas.y);
            ctx.stroke();

            const arrowLen = 8;
            const angle = Math.atan2(toCanvas.y - fromCanvas.y, toCanvas.x - fromCanvas.x);
            ctx.beginPath();
            ctx.moveTo(toCanvas.x - arrowLen * Math.cos(angle - Math.PI / 6),
                      toCanvas.y - arrowLen * Math.sin(angle - Math.PI / 6));
            ctx.lineTo(toCanvas.x, toCanvas.y);
            ctx.lineTo(toCanvas.x - arrowLen * Math.cos(angle + Math.PI / 6),
                      toCanvas.y - arrowLen * Math.sin(angle + Math.PI / 6));
            ctx.stroke();
        }

        function formatNumber(num) {
            return num.toFixed(2).replace('.', ',');
        }

        function drawShape(shape, isOriginal = true, alpha = 1) {
            if (shape.length === 0) return;

            const canvasPoints = shape.map(p => worldToCanvas(p.x, p.y));

            if (isOriginal) {
                ctx.strokeStyle = config.originalColor;
                ctx.lineWidth = 2;
                ctx.fillStyle = 'transparent';
            } else {
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.lineWidth = 2;
                ctx.fillStyle = `rgba(124, 77, 255, ${0.3 * alpha})`;
            }

            ctx.beginPath();
            ctx.moveTo(canvasPoints[0].x, canvasPoints[0].y);
            for (let i = 1; i < canvasPoints.length; i++) {
                ctx.lineTo(canvasPoints[i].x, canvasPoints[i].y);
            }
            ctx.closePath();

            if (!isOriginal) {
                ctx.fill();
            }
            ctx.stroke();

            ctx.fillStyle = config.labelColor;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.font = `600 ${config.labelSize - 2}px Inter, sans-serif`;

            for (let i = 0; i < canvasPoints.length; i++) {
                const label = String.fromCharCode(65 + i);
                const suffix = isOriginal ? '' : "'";
                ctx.fillText(label + suffix, canvasPoints[i].x + 10, canvasPoints[i].y - 10);
            }
        }

        function render() {
            const dim = getCanvasDimensions();
            ctx.clearRect(0, 0, dim.width, dim.height);

            drawGrid();
            drawAxes();
            drawReflectionAxis();
            drawRotationCenter();
            drawTranslationVector();

            const originalShape = shapes[state.shape];
            const transformedShape = transformShape(originalShape, state.animationProgress);

            drawShape(originalShape, true);
            drawShape(transformedShape, false, state.animationProgress);
        }

        // ============================================
        // ANIMATION LOOP
        // ============================================
        let animationStartTime = null;
        const animationDuration = 2000;

        function animate(timestamp) {
            if (!state.animationEnabled) {
                state.animationProgress = 1;
                render();
                requestAnimationFrame(animate);
                return;
            }

            if (animationStartTime === null) {
                animationStartTime = timestamp;
            }

            const elapsed = timestamp - animationStartTime;
            state.animationProgress = Math.min(elapsed / animationDuration, 1);

            if (state.animationProgress >= 1) {
                animationStartTime = null;
            }

            render();
            requestAnimationFrame(animate);
        }

        requestAnimationFrame(animate);

        // ============================================
        // UI EVENT HANDLERS
        // ============================================
        document.getElementById('shapeSelect').addEventListener('change', (e) => {
            state.shape = e.target.value;
            state.animationProgress = state.animationEnabled ? 0 : 1;
            animationStartTime = null;
        });

        document.getElementById('transformSelect').addEventListener('change', (e) => {
            state.transform = e.target.value;
            updateControlsVisibility();
            state.animationProgress = state.animationEnabled ? 0 : 1;
            animationStartTime = null;
        });

        document.getElementById('reflectionAxis').addEventListener('change', (e) => {
            state.reflectionAxis = e.target.value;
            state.animationProgress = state.animationEnabled ? 0 : 1;
            animationStartTime = null;
        });

        document.getElementById('rotationAngle').addEventListener('input', (e) => {
            state.rotationAngle = parseFloat(e.target.value);
            document.getElementById('rotationDisplay').textContent = state.rotationAngle + '°';
            state.animationProgress = state.animationEnabled ? 0 : 1;
            animationStartTime = null;
        });

        document.getElementById('translationX').addEventListener('input', (e) => {
            state.translationX = parseFloat(e.target.value);
            document.getElementById('translationXDisplay').textContent = formatNumber(state.translationX);
            state.animationProgress = state.animationEnabled ? 0 : 1;
            animationStartTime = null;
        });

        document.getElementById('translationY').addEventListener('input', (e) => {
            state.translationY = parseFloat(e.target.value);
            document.getElementById('translationYDisplay').textContent = formatNumber(state.translationY);
            state.animationProgress = state.animationEnabled ? 0 : 1;
            animationStartTime = null;
        });

        document.getElementById('scalingFactor').addEventListener('input', (e) => {
            state.scalingFactor = parseFloat(e.target.value);
            document.getElementById('scalingDisplay').textContent = formatNumber(state.scalingFactor);
            state.animationProgress = state.animationEnabled ? 0 : 1;
            animationStartTime = null;
        });

        document.getElementById('animToggle').addEventListener('click', (e) => {
            state.animationEnabled = !state.animationEnabled;
            const btn = e.target;
            btn.textContent = state.animationEnabled ? 'An' : 'Aus';
            btn.classList.toggle('active', state.animationEnabled);
            state.animationProgress = state.animationEnabled ? 0 : 1;
            animationStartTime = null;
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            state.shape = 'triangle';
            state.transform = 'reflection';
            state.reflectionAxis = 'x';
            state.rotationAngle = 45;
            state.translationX = 2;
            state.translationY = 2;
            state.scalingFactor = 1.5;
            state.animationEnabled = false;
            state.animationProgress = 1;
            animationStartTime = null;

            document.getElementById('shapeSelect').value = 'triangle';
            document.getElementById('transformSelect').value = 'reflection';
            document.getElementById('reflectionAxis').value = 'x';
            document.getElementById('rotationAngle').value = '45';
            document.getElementById('rotationDisplay').textContent = '45°';
            document.getElementById('translationX').value = '2';
            document.getElementById('translationXDisplay').textContent = '2,00';
            document.getElementById('translationY').value = '2';
            document.getElementById('translationYDisplay').textContent = '2,00';
            document.getElementById('scalingFactor').value = '1.5';
            document.getElementById('scalingDisplay').textContent = '1,50';
            document.getElementById('animToggle').textContent = 'Aus';
            document.getElementById('animToggle').classList.remove('active');

            updateControlsVisibility();
        });

        function updateControlsVisibility() {
            document.getElementById('reflectionControls').style.display =
                state.transform === 'reflection' ? 'flex' : 'none';
            document.getElementById('rotationControls').style.display =
                state.transform === 'rotation' ? 'flex' : 'none';
            document.getElementById('translationControls').style.display =
                state.transform === 'translation' ? 'flex' : 'none';
            document.getElementById('scalingControls').style.display =
                state.transform === 'scaling' ? 'flex' : 'none';
        }

        updateControlsVisibility();
    </script>
</body>
</html>
